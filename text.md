## 테스트 코드를 짜야하는 이유
많은 개발자들은 테스트 코드를 작성해야 한다고 한다. 블로그에서, 유튜브에서 테스트 코드의 중요성에 대해 말한다. 하지만 진지하게 고민해보자. 과연 테스트 코드를 정말 짜야할까? 몇 년 전까지만 해도 테스트 코드를 작성하지 않고도 훌륭한 프로덕트들은 많이 탄생했다. 그런데 왜 테스트 코드를 짜야한다고 왜 그렇게 유난법석들을 떨까?

- 많은 개발자들은 코드의 구현을 생각하는데, 테스트 주도 개발을 하면 행동에 집중하게 됨. 이는 solid 원칙을 지키는 것
- 테스트 코드를 짜면 내가 짠 코드에서 신호를 보내는 경우가 있음. 이를 캐치하면 설계적으로 이점을 누릴 수 있음. (로그인 한 시간을 검증해야 하는 경우)
- 안심하고 코드를 배포할 수 있음. 테스트코드로 많은 커버러지를 커버했다면 배포할 때 불안하지 않음.

테스트를 실패하는 경우
- 레거시 코드에 테스트를 우겨넣으면 안 된다. 테스트의 목적은 회귀 버그 방지 및 유연한 설계로의 개선이 있음. 설계의 개선은 테스트를 쉽게 많들어주고 테스트를 결정적이게 많들어준다.
- 레거시에 테스트를 넣으려면 코드 개선이 필요하다.
- 커버러지에 집착하면 안 된다.


해결책
- 테스트와 확장성을 동시에 지닌 서비스의 성장 방식
- 기존의 서비스는 소형차에서 중형차, 대형차로 가는 과정 속에서 프로젝트를 갈아 엎으며 설장했다. 기차는 어떤가. 기차는 1량만 늘려주면 무한정으로 확장 가능하다.
- TDD를 논하기 전에 테스트가 가능한 구조로 변경되어야 한다.

테스트의 필요성
- 정상으로 동작하던 코드가 나의 배포로 동작하지 않을 때. 나의 수정이 어떤 영향을 끼치지 알 수 없을 때. 그런 두려움은 곧 비용이다.

좋은 아키텍쳐란? 상호 보완적이다.
  - TEST(회귀버그방지)와 SOLID(좋은 설계)의 교집합
  - 두 개의 이점을 얻어야 테스트의 효용성이 올라감.

좋은 아키텍쳐란?
- SOLID 원칙인데 테스트 코드를 작성하면 이를 입증할 수 있음.

테스트의 3분류
- E2E(5%) -> Large test(대형 테스트)
  - 멀티 서버, End To End 테스트
- INTEGRATION(15%) -> Medium Test(중형 테스트)
  - -> H2 같은 테스트 DB 사용 가능. 단일 서버, 멀티 프로세스, 멀티 스레드
- UNIT(80%) -> Small Test(소형 테스트)
  - 단일 서버, 프로세스, 스레드 및 디스크 I/O 사용 금지, Blocking call 사용 금지(스레드.slepp...) 

테스트 3분류
- 레드 단계 : 실패하는 테스트
- 그린 단계 : 성공하는 테스트
- 블루 단계 : 리펙토링(이 과정은 파괴적일 수 있음)

## 테스트에 필요한 개념
### 1. 개념
SUT
> System under Test

BDD - 테스트를 작성하면 어디에 어떻게 테스트를 넣어야 하지? 의문이 드는데 이때 BDD는 행동에 집중하라 말한다.
> Behaviour Driven Development(given - when - then)

상호 작용 테스트
> 대상 함수의 구현을 호출하지 않으면서 호출되었는지 검증하는 방법

호불호가 있는 테스트. 내부 구현이 어떻게 되었는지 감시하는 테스트.캡슐화 위배. 객체에게 위임한 책임을 객체가 수행했는지만 확인하면 되는데 이를 감시하는 것. 구현에 집착하는 것.

상태 기반 검증 vs 행위 기반 검증
> 상태 기반은 어떤 값을 시스템에 넣었을 때 나오는 결과값을 기대값과 비교하는 방식. 행위 기반 검증은 상호 작용 테스트라 보면 된다. BDD의 '행위'와 행위 기반 검증의 행위의 의미는 다르다.

테스트 픽스처
> 테스트 전에 필요한 자원을 생성하는 것. BeforeEach처럼 미리 테스트에 필요한 자원을 만들어 두는 것.

비욘세 규칙
> 유지하고 싶은 정책이 있으면 알아서 규칙을 만들어야 한다.
> 비욘세의 곡 싱글 레이디 중
> <<네가 나를 좋아했다면, 프로포즈를 했어야지>> ->
> <<상태를 유지하고 싶었으면, 테스트를 만들었어야지>>

무슨 테스트를 짜야할 지 모르겠다면 유지하고 싶은 상태를 테스트로 작성. userId가 이메일이었으면 좋겠으면 userId가 이메일이 아니면 예외를 던지는 코드를 짜면 됨.

테스트는 계약이다. 다른 개발자와 협업 가운데 내가짠 테스트 코드가 있다면 해당 테스트 코드를 보고 상대방은 자신의 코드가 내가 짠 코드 환경에서 어떤 영향을 미칠지 예측할 수 있음.
 
 Testability
 > 테스트 가능성. 소프트웨어가 테스트 가능한 구조인가?

 Test double
 > 테스트 대역

 회원가입 시 이메일 전송이 되어야 한다면 이메일 전송은 대역으로 대체한다.
 대역에는 다음이 있음.
 1. Dummy. 아무런 동작 않고 코드가 돌아가기 위해 전달하는 객체
 2. Local에서 테스트에서 사용하기위해 만든 가짜 객체. 자체 로직이 있음.
 3. stub. 미리 준비된 값을 출력하는 객체
 4. Mock -> Test double과 동일시해버림. 메소드 호출을 확인하기 위한 객체. 자가 검증 능력을 갖춤. 사실상 테스트 더블과 동일한 의미로 사용됨.
 5. Spy -> 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체

## 의존성
의존성이란 무엇인가? A는 B를 사용하기만 해도 A는 B에 의존한다 할 수 있다.
